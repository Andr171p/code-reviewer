# Тексты модулей

## Область применения: управляемое приложение, мобильное приложение, обычное приложение.

1. Тексты модулей должны быть написаны на русском языке.

Исключение составляют веб-сервисы, имена методов и параметров которых рекомендуется задавать на английском языке (например, метод TestConnection веб-сервиса EnterpriseDataExchange), а также различные идентификаторы сторонних информационных систем, например, названия полей «внешних» структур данных, которые программно обрабатываются в коде.

1.1. В текстах модулей не допускается использовать букву "ё".

Исключения составляют интерфейсные тексты, выводимые пользователю в сообщениях, формах и справке, где употребление буквы «ё» в ряде случаев допустимо. Подробнее см. Тексты.

1.2. Кроме того, в текстах модулей не допускается использовать неразрывные пробелы и знак минус "-" в других кодировках (короткое, длинное тире и т.п.).

Такие символы часто оказываются в тексте модулей при копировании из офисных документов и приводят к ряду сложностей при разработке. Например, не работает поиск фрагментов текста, включающих «неправильные» минусы и пробелы; некорректно выводятся подсказки типов параметров процедур и функций в конфигураторе и расширенная проверка в 1С:EDT; указание «неправильного» минуса в выражениях приведет к синтаксической ошибке.

Методическая рекомендация (полезный совет)

2. Программные модули не должны иметь неиспользуемых процедур и функций.

3. Программные модули не должны иметь закомментированных фрагментов кода, а также фрагментов, которые каким-либо образом связаны с процессом разработки (отладочный код, служебные отметки, например, TODO, MRG и т.п.) и с конкретными разработчиками этого кода. Например, недопустимо оставлять подобные фрагменты в коде после завершения отладки или рефакторинга:

```bsl
Процедура ПередУдалением(Отказ)
//    Если Истина Тогда
//        Сообщение("Для отладки");
//    КонецЕсли;
КонецПроцедуры
```

также неправильно:

```bsl
Процедура ПередУдалением(Отказ)
    Если Истина Тогда
        // Иванов: доделать
    КонецЕсли;
КонецПроцедуры
```

Правильно: после завершения отладки или рефакторинга удалить обработчик ПередУдалением из кода.

Неправильно в текстах запросов использовать комментарии для их модификации:

```bsl
ТекстЗапроса = "ВЫБРАТЬ
|	Контрагенты.Ссылка КАК Ссылка
|// ПОМЕСТИТЬ втКонтрагенты
|ИЗ
|	Справочник.Контрагенты КАК Контрагенты";

Если ВыгрузитьВоВременнуюТаблицу Тогда
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "// ПОМЕСТИТЬ", "ПОМЕСТИТЬ");
КонецЕсли;
```

О модификации текстов запросов смотрите п.6 стандарта Оформление текстов запросов

4. Тексты модулей оформляются по принципу "один оператор в одной строке". Наличие нескольких операторов допускается только для "однотипных" операторов присваивания, например:

```bsl
НачальныйИндекс = 0; Индекс = 0; Результат = 0;
```

5. Текст модуля должен быть оформлен синтаксическим отступом. Для синтаксического отступа используется табуляция, а не пробелы (чтобы при смене числа знаков в табуляции выравнивание текста сохранялось).

Размер табуляции - стандартный, 4 символа.

5.1. С крайней левой позиции должны начинаться только:
 - операторы Процедура, КонецПроцедуры, Функция, КонецФункции;
 - заголовки (описания) процедур и функций;
 - объявление переменных модуля;
 - код вне процедур и функций (с учетом синтаксического отступа);
 - директивы компилятора &НаКлиенте, &НаСервере и т.д. и аннотации &Перед, &После и др.
 - инструкции препроцессора (в т.ч. #Область и #КонецОбласти)

5.2. Процедуры НачатьТранзакцию и ЗафиксироватьТранзакцию не являются операторными скобками, поэтому текст внутри этих процедур не сдвигается.

6. При длине строки более 120 символов следует использовать переносы (табуляция занимает 4 символа, согласно п.5). Строки длиннее 120 символов делать не рекомендуется, за исключением тех случаев, когда перенос невозможен - например, в коде определена длинная строковая константа, которая выводится без переносов в окно сообщений с помощью объекта СообщениеПользователю.

7.1. Тексты модулей могут содержать комментарии. Комментарии должны быть достаточно понятными, чтобы пояснять работу модуля или комментируемого оператора. Тексты комментариев должны составляться по правилам русского языка, в деловом стиле, быть эмоционально сдержанными и не содержать слов, не относящихся к функциональности программы.

7.2. Небольшие комментарии пишутся в конце строки, которую комментируют, например:

НайденныеОшибки.Колонки.Добавить("Номер"); // для совместимости
7.3. Большие комментарии или комментарии к фрагменту кода пишутся перед комментируемым кодом в отдельной строке. Текст выравнивается по левой границе комментируемого фрагмента. Между символами комментария "//" и текстом комментария должен быть пробел.

```bsl
// Инициализируем переменные для выполнения расчетов,
// которые выполняются далее по тексту модуля.
ТекущаяДата = ОбщегоНазначения.ПолучитьРабочуюДату();
ТекущийГод = Год(ТекущаяДата);
ТекущийМесяц = Месяц(ТекущаяДата);
ТекущаяНеделя = НеделяГода(ТекущаяДата);
ТекущийДень = День(ТекущаяДата);
```

8. Тексты больших процедур и функций можно разбивать на отдельные сворачиваемые области. При этом имена областей должны удовлетворять требованиям стандарта Правила образования имен переменных

Для автоматического форматирования кода можно воспользоваться обработкой автоформатирования кода и локализации.

# Правила создания общих модулей

**Область применения: управляемое приложение, мобильное приложение, обычное приложение.**

1.1. Общие модули создаются для реализации процедур и функций, объединенных по некоторому признаку. Как правило, в один общий модуль помещаются процедуры и функции одной подсистемы конфигурации (продажи, закупки) или процедуры и функции сходного функционального назначения (работа со строками, общего назначения).

1.2. При разработке общих модулей следует выбирать один из четырех контекстов выполнения кода:

| Тип общего модуля               | Пример наименования            | Вызов сервера | Сервер | Внешнее соединение | Клиент (обычное приложение) | Клиент (управляемое приложение) |
|-------------------------------|-------------------------------|---------------|--------|-------------------|-----------------------------|---------------------------------|
| Серверный                     | ОбщегоНазначения (или ОбщегоНазначенияСервер) | ✔️            | ✔️     | ✔️               |                             |                                |
| Серверный для вызова с клиента | ОбщегоНазначенияВызовСервера | ✔️            | ✔️     |                   |                             |                                |
| Клиентский                    | ОбщегоНазначенияКлиент (или ОбщегоНазначенияГлобальный) |               |        |                   | ✔️                         | ✔️                             |
| Клиент-серверный              | ОбщегоНазначенияКлиентСервер |               | ✔️     | ✔️               | ✔️                         | ✔️                             |

2.1. Серверные общие модули предназначены для размещения серверных процедур и функций, не доступных для использования из клиентского кода. В них реализуется вся внутренняя серверная бизнес-логика приложения.
Для корректной работы конфигурации в режимах внешнего соединения, управляемого и обычного приложений, серверные процедуры и функции следует размещать в общих модулях с признаками:

 - Сервер (флажок Вызов сервера снят),
 - Клиент (обычное приложение),
 - Внешнее соединение.

В таком случае гарантируется возможность вызова серверных процедур и функций с параметрами мутабельных типов (например, СправочникОбъект, ДокументОбъект и т.п.). Как правило, это:
 - обработчики подписок на события документов, справочников и т.п., которые принимают в качестве параметра мутабельное значение (объект).
 - серверные процедуры и функции, в которые в качестве параметра передается объект из модулей справочников, документов и пр., а также из модулей с подписками на события.
 - Серверные общие модули называются по общим правилам именования объектов метаданных.

Например: РаботаСФайлами, FilesOperations.

В отдельных случаях для предотвращения конфликта имен со свойствами глобального контекста может быть добавлен постфикс "Сервер" (англ. "Server").
Например: РегламентныеЗаданияСервер, ScheduledJobsServer.

2.2. Серверные общие модули для вызова с клиента содержат серверные процедуры и функции, доступные для использования из клиентского кода. Они составляют клиентский программный интерфейс сервера приложения.
Такие процедуры и функции размещаются в общих модулях с признаком:

Сервер (флажок Вызов сервера установлен)
Серверные общие модули для вызова с клиента называются по общим правилам именования объектов метаданных и должны именоваться с постфиксом "ВызовСервера" (англ. "ServerCall").
Например: РаботаСФайламиСлужебныйВызовСервера, FilesOperationsInternalServerCall.

Следует иметь в виду, что экспортные процедуры и функции в таких общих модулях не должны содержать параметров мутабельных типов (СправочникОбъект, ДокументОбъект и т.п.), так как их передача из (или в) клиентского кода невозможна.

См. также: Ограничение на установку признака «Вызов сервера» у общих модулей, Обеспечение совместимости библиотек

2.3. Клиентские общие модули содержат клиентскую бизнес-логику (функциональность, определенную только для клиента) и имеют признаки:
 - Клиент (управляемое приложение),
 - Клиент (обычное приложение).
 - Исключение составляют случаи, когда клиентские процедуры и функции должны быть доступны только в режиме управляемого приложения (только в режиме обычного приложения или только в режиме внешнего соединения). В таких случаях, допустима иная комбинация двух этих признаков.

Клиентские общие модули именуются с постфиксом "Клиент" (англ. "Client").
Например: РаботаСФайламиКлиент, FilesOperationsClient.

См. также: минимизация кода, выполняемого на клиенте

2.4. Для того чтобы избежать дублирования кода, рекомендуется создавать клиент-серверные общие модули с теми процедурами и функциями, содержание которых одинаково на сервере и на клиенте. Такие процедуры и функции размещаются в общих модулях с признаками:
 - Клиент (управляемое приложение),
 - Сервер (флажок Вызов сервера сброшен),
 - Клиент (обычное приложение),
 - Внешнее соединение.

Общие модули этого вида именуются с постфиксом "КлиентСервер" (англ. "ClientServer").
Например: РаботаСФайламиКлиентСервер, FilesOperationsClientServer.

В то же время, как только возникает необходимость ветвить код в клиент-серверных общих модулях на серверный и клиентский, то не следует использовать для этого инструкции препроцессора. Вместо этого, функциональность, различную для клиента и для сервера, рекомендуется реализовывать по общим правилам в модулях соответствующего типа – см. пп. 2.1 и 2.3. Такое явное разделение клиентской и серверной бизнес-логики продиктовано соображениями повышения модульности прикладного решения, упрощения контроля со стороны разработчика над клиент-серверным взаимодействием и снижением риска ошибок из-за принципиальных отличий требований к разработке клиентского и серверного кода (необходимость минимизации кода, выполняемого на клиенте, разной доступностью объектов и типов платформы и др.). При этом нужно иметь в виду неизбежное увеличение числа общих модулей в конфигурации.

Подробнее см.: Использование директив компиляции и инструкций препроцессора

Особым случаем смешанных клиент-серверных модулей являются модули форм и команд, которые специально предназначены для реализации серверной и клиентской бизнес-логики в одном модуле.

3.1. Имена общих модулей рекомендуется строить по общим правилам именования объектов метаданных. Название общего модуля должно совпадать с названием подсистемы или отдельного механизма, процедуры и функции которой он реализует. Рекомендуется избегать в названиях общих модулей таких общих слов как "Процедуры", "Функции", "Обработчики", "Модуль", "Функциональность" и т.п. и применять их только в исключительных случаях, когда они более полно раскрывают назначение модуля.

Для того чтобы различать общие модули одной подсистемы, которые созданы для реализации процедур и функций, выполняемых в разных контекстах, рекомендуется задавать им постфиксы, описанные ранее в пп. 2.1-2.4.

3.2. Дополнительно к общим модулям могут быть добавлены уточняющие постфиксы.

3.2.1. Для глобальных модулей добавляется постфикс "Глобальный" (англ. "Global"), в этом случае постфикс "Клиент" добавлять не следует.
Например: РаботаСФайламиСлужебныйГлобальный, FilesOperationsInternalGlobal.

3.2.2. Модули, выполняющиеся в привилегированном режиме, имеющие признак Привилегированный, именуются с постфиксом "ПолныеПрава" (англ. "FullAccess").
Например: РаботаСФайламиСлужебныйПолныеПрава, FilesOperationsInternalFullAccess.

3.2.3. Модули, предназначенные для реализации на сервере или на клиенте функций с повторным использованием возвращаемых значений (на время вызова или на время сеанса), именуются с постфиксом "ПовтИсп" (англ. "Cached") и "КлиентПовтИсп" (англ. "ClientCached") соответственно.
Например: РаботаСФайламиСлужебныйКлиентПовтИсп, FilesOperationsInternalClientCached.

См. также: Обеспечение совместимости библиотек

3.2.4. Серверные и клиентские модули библиотечных конфигураций (которые предназначены не для самостоятельного использования, а для разработки других конфигураций) с процедурами и функциями, допускающие изменение своей реализации, именуются с постфиксами "Переопределяемый" (англ. "Overridable") и "КлиентПереопределяемый" (англ. "ClientOverridable").
Например: РаботаСФайламиКлиентПереопределяемый, FilesOperationsClientOverridable.

См. также: Переопределяемые и поставляемые объекты библиотеки

3.2.5. В локализуемых конфигурациях, на базе которых выпускаются национальные прикладные решения для различных стран или регионов, модули, реализующие национальную специфику, именуются с постфиксами "Локализация" (англ. "Localization") и "КлиентЛокализация" (англ. "ClientLocalization").
Например: ЭлктроннаяПодписьСлужебныйЛокализация, ElectonicSignatureInternalLocalization.


# Структура модуля

**Область применения: управляемое приложение, мобильное приложение, обычное приложение.**

1.1. В программном модуле (общие модули, модули объектов, модули менеджеров объектов, модули форм, команд и т.п.) в общем случае могут присутствовать следующие разделы в приведенной ниже последовательности:
 - заголовок модуля
 - раздел описания переменных
 - экспортные процедуры и функции модуля, составляющие его программный интерфейс
 - обработчики событий объекта (формы)
 - служебные процедуры и функции модуля
 - раздел инициализации

Некоторые разделы могут присутствовать только в модулях определенного вида. Например, обработчики событий элементов форм могут присутствовать только в модулях форм, а раздел описания переменных и раздел инициализации не могут быть определены в неглобальных общих модулях, модулях менеджеров объектов, наборов записей, значений констант и модуле сеанса.

Требование о разделении кода модуля на разделы призвано повысить читаемость кода и упростить внесение изменений в код разными авторами (разработчиками) как при коллективной разработке, так и при доработке прикладных решений на конкретных внедрениях.

1.2. Объемные разделы модулей рекомендуется разбивать на подразделы по функциональному признаку.

1.3. Разделы и подразделы оформляются в виде областей. При этом имена областей должны удовлетворять требованиям стандарта Правила образования имен переменных

1.4. Шаблон (заготовка для копирования) разделов для общих модулей:

```bsl
#Область ПрограммныйИнтерфейс
// Код процедур и функций
#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс
// Код процедур и функций
#КонецОбласти

#Область СлужебныеПроцедурыИФункции
// Код процедур и функций
#КонецОбласти
англ.

#Region Public
// Enter code here.
#EndRegion

#Region Internal
// Enter code here.
#EndRegion

#Region Private
// Enter code here.
#EndRegion
```

Раздел «Программный интерфейс» содержит экспортные процедуры и функции, предназначенные для использования другими объектами конфигурации или другими программами (например, через внешнее соединение).
Раздел «Служебный программный интерфейс»  предназначен для модулей, которые являются частью некоторой функциональной подсистемы. В нем должны быть размещены экспортные процедуры и функции, которые допустимо вызывать только из других функциональных подсистем этой же библиотеки.
Раздел «Служебные процедуры и функции» содержит процедуры и функции, составляющие внутреннюю реализацию общего модуля. В тех случаях, когда общий модуль является частью некоторой функциональной подсистемы, включающей в себя несколько объектов метаданных, в этом разделе также могут быть размещены служебные экспортные процедуры и функции, предназначенные только для вызова из других объектов данной подсистемы.

Для объемных общих модулей рекомендуется разбивать этот раздел на подразделы, по функциональному признаку. Например:

```bsl
русск.

#Область ОбновлениеИнформационнойБазы
// Код процедур и функций
#КонецОбласти
англ.

#Region InfobaseUpdate
// Enter code here.
#EndRegion
```

1.5. Шаблон оформления разделов для модулей объектов, менеджеров, наборов записей, обработок, отчетов и т.п.:

```bsl
русск.

#Область ОписаниеПеременных

#КонецОбласти

#Область ПрограммныйИнтерфейс
// Код процедур и функций
#КонецОбласти

#Область ОбработчикиСобытий
// Код процедур и функций
#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс
// Код процедур и функций
#КонецОбласти

#Область СлужебныеПроцедурыИФункции
// Код процедур и функций
#КонецОбласти

#Область Инициализация

#КонецОбласти
англ.

#Region Variables

#EndRegion

#Region Public
// Enter code here.
#EndRegion

#Region EventHandlers
// Enter code here.
#EndRegion

#Region Internal
// Enter code here.
#EndRegion

#Region Private
// Enter code here.
#EndRegion

#Region Initialize

#EndRegion
```

Раздел «Программный интерфейс» содержит экспортные процедуры и функции, предназначенные для использования в других модулях конфигурации или другими программами (например, через внешнее соединение). Не следует в этот раздел помещать экспортные функции и процедуры, которые предназначены для вызова исключительно из модулей самого объекта, его форм и команд. Например, процедуры заполнения табличной части документа, которые вызываются из обработки заполнения в модуле объекта и из формы документа в обработчике команды формы не являются программным интерфейсом модуля объекта, т.к. вызываются только в самом модуле и из форм этого же объекта. Их следует размещать в разделе «Служебные процедуры и функции».
Раздел «Обработчики событий» содержит обработчики событий модуля объекта (ПриЗаписи, ПриПроведении и др.)
Раздел «Служебный программный интерфейс» имеет такое же предназначение, как и в общих модулях.
Раздел «Служебные процедуры и функции» имеет такое же предназначение, как и в общих модулях.
1.6. Шаблон оформления разделов для модулей форм:

```bsl
русск.

#Область ОписаниеПеременных

#КонецОбласти

#Область ОбработчикиСобытийФормы
// Код процедур и функций
#КонецОбласти

#Область ОбработчикиСобытийЭлементовШапкиФормы
// Код процедур и функций
#КонецОбласти

#Область ОбработчикиСобытийЭлементовТаблицыФормы<ИмяТаблицыФормы>
// Код процедур и функций
#КонецОбласти

#Область ОбработчикиКомандФормы
// Код процедур и функций
#КонецОбласти

#Область СлужебныеПроцедурыИФункции
// Код процедур и функций
#КонецОбласти
англ.

#Region Variables

#EndRegion

#Region FormEventHandlers
// Enter code here.
#EndRegion

#Region FormHeaderItemsEventHandlers
// Enter code here.
#EndRegion

#Region FormTableItemsEventHandlers<FormTableName>
// Enter code here.
#EndRegion

#Region FormCommandsEventHandlers
// Enter code here.
#EndRegion

#Region Private
// Enter code here.
#EndRegion
```

Раздел «Обработчики событий формы» содержит процедуры-обработчики событий формы: ПриСозданииНаСервере, ПриОткрытии и т.п.
Раздел «Обработчики событий элементов шапки формы» содержит процедуры-обработчики элементов, расположенных в основной части формы (все, что не связано с таблицами на форме).
В разделах «Обработчики событий элементов таблицы формы <имя таблицы формы>» размещаются процедуры-обработчики таблиц формы и элементов таблиц. Для процедур-обработчиков каждой таблицы должен быть создан свой раздел.
Раздел «Обработчики команд формы» содержит процедуры-обработчики команд формы (имена которых задаются в свойстве Действие команд формы).
Раздел «Служебные процедуры и функции» имеет такое же предназначение, что и в общих модулях.
См. также: Правила создания модулей форм

1.7. Шаблон оформления разделов для модулей команд:

```bsl
русск.

#Область ОбработчикиСобытий
// Код процедур и функций
#КонецОбласти

#Область СлужебныеПроцедурыИФункции
// Код процедур и функций
#КонецОбласти
англ.

#Region EventHandlers
// Enter code here.
#EndRegion

#Region Private
// Enter code here.
#EndRegion
```

Раздел «Обработчики событий» содержит процедуру-обработчик команды ОбработкаКоманды.
Раздел «Служебные процедуры и функции» имеет такое же предназначение, что и в общих модулях.
1.8. В модуле не должно быть пустых областей.

2. Общие требования к разделам программных модулей.

2.1. Заголовок модуля представляет собой комментарий в самом начале модуля. В заголовке модуля приводится его краткое описание и условия применения.
Например:

```bsl
////////////////////////////////////////////////////////////////////////////////
// Клиентские процедуры и функции общего назначения:
// - для работы со списками в формах;
// - для работы с журналом регистрации;
// - для обработки действий пользователя в процессе редактирования
//   многострочного текста, например комментария в документах;
// - прочее.
//
////////////////////////////////////////////////////////////////////////////////
Для модулей форм в заголовке рекомендуется размещать описание параметров формы.

2.2. Раздел описания переменных. Имена переменных назначаются согласно общим правилам образования имен переменных, а их использование описывается в статье Использование глобальных переменных в программных модулях.

Все переменные модуля должны быть снабжены комментарием, достаточным для понимания их назначения. Комментарий рекомендуется размещать в той же строке, где объявляется переменная.
Пример:

русск.

#Область ОписаниеПеременных

Перем ВалютаУчета;
Перем АдресПоддержки;
...

#КонецОбласти
англ.

#Region Variables

Var PresentationCurrency;
Var SupportEmail;
...

#EndRegion
```

2.3. Программный интерфейс. Экспортные процедуры и функции, составляющие программный интерфейс модуля, размещаются сразу же после описания переменных. Такие процедуры и функции предназначены для использования другими объектами конфигурации или другими программами (например, через внешнее соединение), поэтому должны быть расположены в модуле на "видном месте".

См. также: Описание процедур и функций

2.4.1. Обработчики событий формы, команд и элементов формы. Перед служебными процедурами и функциями в модуле формы располагаются обработчики событий формы, а также обработчики событий команд и элементов формы.

Методическая рекомендация (полезный совет)

2.4.2. Рекомендуется обработчики одного элемента формы располагать вместе, придерживаясь, при этом, порядка их следования в панели свойств редактора формы в конфигураторе.

2.4.3. У каждого события должна быть назначена своя процедура-обработчик. Если одинаковые действия должны выполняться при возникновении событий в разных элементах формы следует:

создать отдельную процедуру (функцию), выполняющую необходимые действия
для каждого элемента формы создать отдельный обработчик с именем, назначаемым по умолчанию
из каждого обработчика вызвать требуемую процедуру (функцию).
Например, неправильно:

```bsl
&НаКлиенте
Процедура ПоИсполнителюПриИзменении(Элемент)
 ПараметрыОтбора = Новый Соответствие();
 ПараметрыОтбора.Вставить("ПоАвтору", ПоАвтору);
 ПараметрыОтбора.Вставить("ПоИсполнителю", ПоИсполнителю);
 УстановитьОтборСписка(Список, ПараметрыОтбора);
КонецПроцедуры

&НаКлиенте
Процедура ПоАвторуПриИзменении(Элемент)
 ПоИсполнителюПриИзменении(Неопределено);
КонецПроцедуры
правильно:

&НаКлиенте
Процедура ПоИсполнителюПриИзменении(Элемент)
 УстановитьОтбор();
КонецПроцедуры

&НаКлиенте
Процедура ПоАвторуПриИзменении(Элемент)
 УстановитьОтбор();
КонецПроцедуры

&НаСервере
Процедура УстановитьОтбор()
 ПараметрыОтбора = Новый Соответствие();
 ПараметрыОтбора.Вставить("ПоАвтору", ПоАвтору);
 ПараметрыОтбора.Вставить("ПоИсполнителю", ПоИсполнителю);
 УстановитьОтборСписка(Список, ПараметрыОтбора);
КонецПроцедуры
```

Это требование обусловлено тем, что логически процедуры-обработчики событий не предназначены для использования в коде модуля, а вызываются непосредственно платформой. Смешение же этих двух сценариев в одной процедуре неоправданно усложняет ее логику и снижает ее устойчивость (вместо одного предусмотренного сценария вызова - по событию из платформы - код процедуры должен рассчитывать и на другие "прямые" вызовы из кода).

2.5. Обработчики событий модулей объекта и менеджера объекта размещаются после раздела с программным интерфейсом, но до служебных процедур и функций модуля.
Методическая рекомендация (полезный совет)

2.5.1. Рекомендуется располагать обработчики, придерживаясь порядка их следования в описании встроенного языка.


2.6. Служебные процедуры и функции модуля, которые не являются обработчиками событий, а составляют внутреннюю реализацию модуля, размещаются в модуле следом за обработчиками событий.

В тех случаях когда общий модуль является частью некоторой функциональной подсистемы, включающей в себя несколько объектов метаданных, в этом разделе также могут быть размещены служебные экспортные процедуры и функции, предназначенные только для вызова из других объектов данной подсистемы.

Процедуры и функции, связанные между собой по характеру или по логике работы рекомендуется располагать вместе. В модулях форм не рекомендуется явно группировать процедуры и функции модуля на серверные, клиентские и функции без контекста, так как такое «технологическое» упорядочивание затрудняет понимание логики модуля, отвлекая внимание разработчика на детали ее реализации.

2.7. Раздел инициализации содержит операторы, инициализирующие переменные модуля или объект (форму).
Например:

```bsl
русск.

#Область Инициализация

АдресПоддержки = "v8@1c.ru";
ВыполнитьИнициализацию();
...

#КонецОбласти
англ.

#Region Initialize

SupportEmail = "v8@1c.ru";
Ctor();
...

#EndRegion
```

Для оформления разделов кода в виде областей рекомендуется воспользоваться приложенной обработкой.
